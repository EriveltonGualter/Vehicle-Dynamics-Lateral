
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Graphics</title><meta name="generator" content="MATLAB 8.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-01-22"><meta name="DC.source" content="Graphics.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Graphics</h1><!--introduction--><p>Functions for graphics generation.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Code</a></li><li><a href="#4">Animation</a></li><li><a href="#5">Frame</a></li><li><a href="#8">Vector</a></li><li><a href="#9">changeMarker</a></li><li><a href="#11">Properties</a></li><li><a href="#13">See Also</a></li></ul></div><h2>Code<a name="1"></a></h2><pre class="codeinput"><span class="keyword">classdef</span> Graphics
</pre><pre class="codeinput">	methods
</pre><pre class="codeinput">        <span class="comment">% Constructor</span>
        <span class="keyword">function</span> self = Graphics(varargin)
            v = VehicleDynamics.VehicleArticulatedNonlinear4DOF;
            <span class="keyword">if</span> nargin == 0
                self.vehicle = v;<span class="comment">%.params;</span>
            <span class="keyword">else</span>
                self.vehicle = varargin{1};<span class="comment">%.params;</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><h2>Animation<a name="4"></a></h2><p>Animates the manoever.</p><p><b>Sintax</b></p><p><tt><i>GraphicsClass</i>.Animation(XOUT,TOUT,saveit)</tt></p><p><b>Arguments</b></p><p>The following table describes the input arguments:</p><p> <table border=1 width="97%">
<tr> <td width="30%"><tt>XOUT</tt></td> <td width="70%">Solution array. Each column corresponds to the solution of each state variable of the vehicle. The columns must respect the following variable order: [XT YT PSI dPSI VT ALPHAT (PHI dPHI)] </td> </tr>
<tr> <td width="30%"><tt>TOUT</tt></td> <td width="70%">Column vector of time points.</td> </tr>
<tr> <td width="30%"><tt>saveit</tt></td> <td width="70%">Flag for saving the animation in a gif file. If savit = 0 the animation will not be saved. If savit = 1 a file Animacao.gif is generated.</td> </tr>
</table> </p><p><b>Description</b></p><p>TEXT</p><pre class="codeinput">        <span class="keyword">function</span> Animation(self,XOUT,TOUT,saveit)
            <span class="comment">% Verificando quantidade de colunas para saber se &#65533; ve&#65533;culo simples ou articulado</span>
            <span class="comment">% col = 6 -&gt; simples</span>
            <span class="comment">% col = 8 -&gt; articulado</span>
            [col] = size(XOUT,2);

            <span class="comment">% States</span>
            XT = XOUT(:,1);                 <span class="comment">% Horizontal position [m]</span>
            YT = XOUT(:,2);                 <span class="comment">% Vertical position [m]</span>
            PSI = XOUT(:,3);                <span class="comment">% Vehicle yaw angle [rad]</span>
            dPSI = XOUT(:,4);               <span class="comment">% Yaw rate [rad/s]</span>
            VT = XOUT(:,5);                 <span class="comment">% Vehicle CG velocity [m/s]</span>
            ALPHAT = XOUT(:,6);             <span class="comment">% Vehicle side slip angle [rad]</span>

            <span class="comment">% Distances</span>
            a = self.vehicle.distFT;        <span class="comment">% Distance FT [m]</span>
            b = self.vehicle.distTR;        <span class="comment">% Distance TR [m]</span>
            lT = self.vehicle.width / 2;  <span class="comment">% Metade da width do vehicle [m]</span>

            <span class="comment">% &#65533;ngulo de deriva na dianteira [rad]</span>
            ALPHAF = atan2((a*dPSI + VT.*sin(ALPHAT)),(VT.*cos(ALPHAT)));
            <span class="comment">% &#65533;ngulo de deriva na traseira [rad]</span>
            ALPHAR = atan2((-b*dPSI + VT.*sin(ALPHAT)),(VT.*cos(ALPHAT)));
            <span class="comment">% OBS: Calculando os &#65533;ngulos de deriva com "atan2", quando o valor chega a</span>
            <span class="comment">% 180 graus fica estranho o vector.</span>

            <span class="comment">% M&#65533;dulo da velocidade no eixo dianteiro [m/s]</span>
            VF = sqrt((VT.*cos(ALPHAT)).^2 + (a*dPSI + VT.*sin(ALPHAT)).^2);
            <span class="comment">% M&#65533;dulo da velocidade no eixo traseiro [m/s]</span>
            VR = sqrt((VT.*cos(ALPHAT)).^2 + (-b*dPSI + VT.*sin(ALPHAT)).^2);

            <span class="comment">% Posi&#65533;&#65533;o relativa dos cantos e eixos</span>
            <span class="comment">% Determina a posi&#65533;&#65533;o dos cantos e eixos do ve&#65533;culo com rela&#65533;&#65533;o ao centro</span>
            <span class="comment">% de massa.</span>

            <span class="comment">% Vectores posi&#65533;&#65533;o 1, 2, 3 e 4 em rela&#65533;&#65533;o a T na base (T t1 t2 t3)</span>
            rt1t = [a;lT];                  <span class="comment">% dianteira esquerda</span>
            rt2t = [a;-lT];                 <span class="comment">% dianteira direita</span>
            rt3t = [-b;-lT];                <span class="comment">% traseira direita</span>
            rt4t = [-b;lT];                 <span class="comment">% traseira esquerda</span>

            eif = [a;0];                    <span class="comment">% Posicao do eixo dianteiro</span>
            eir = [-b;0];                   <span class="comment">% Posicao do eixo trasiero</span>

            <span class="comment">% Evolu&#65533;&#65533;o da posi&#65533;&#65533;o absoluta dos cantos e eixos</span>
            <span class="comment">% Determina a movimenta&#65533;&#65533;o dos pontos devido a mudan&#65533;a de orienta&#65533;&#65533;o do</span>
            <span class="comment">% ve&#65533;culo.</span>

            <span class="comment">% Pre alocando as matrizes</span>

            rt1i = zeros(length(TOUT),2);
            rt2i = zeros(length(TOUT),2);
            rt3i = zeros(length(TOUT),2);
            rt4i = zeros(length(TOUT),2);

            eff = zeros(length(TOUT),2);
            err = zeros(length(TOUT),2);

            <span class="comment">% In&#65533;cio do loop</span>
            <span class="keyword">for</span> j=1:length(TOUT)
                <span class="comment">% Matriz de rota&#65533;&#65533;o da base (T t1 t2 t3) para (o i j k)</span>
                RTI=[cos(PSI(j)) -sin(PSI(j));sin(PSI(j)) cos(PSI(j))];
                <span class="comment">% Vectores posi&#65533;&#65533;o 1, 2, 3 e 4 em rela&#65533;&#65533;o a origem do ref inercial na</span>
                rt1i(j,1:2) = (RTI*rt1t)';
                <span class="comment">% base (T t1 t2 t3)</span>
                rt2i(j,1:2) = (RTI*rt2t)';
                rt3i(j,1:2) = (RTI*rt3t)';
                rt4i(j,1:2) = (RTI*rt4t)';
                <span class="comment">% Posicionando o eixo dianteiro e o traseiro</span>
                eff(j,1:2) = (RTI*eif);     <span class="comment">% Eixo dianteiro</span>
                err(j,1:2) = (RTI*eir);     <span class="comment">% Eixo trasiro</span>
            <span class="keyword">end</span>

            <span class="comment">% Posi&#65533;&#65533;o absoluta dos cantos e eixos</span>
            <span class="comment">% A evolu&#65533;&#65533;o da posi&#65533;&#65533;o absoluta dos pontos ao longo do tempo.</span>

            <span class="comment">% Vectores posi&#65533;&#65533;o 1, 2, 3 e 4 em rela&#65533;&#65533;o a o na base (o i j k)</span>
            rc1t=[XT YT]+rt1i;
            rc2t=[XT YT]+rt2i;
            rc3t=[XT YT]+rt3i;
            rc4t=[XT YT]+rt4i;

            <span class="comment">% Posicionamento absoluto do eixo dianteiro e trasiero</span>
            ef = [XT YT]+eff;
            er = [XT YT]+err;

            <span class="comment">% Ajuste do tempo</span>
            <span class="comment">% A exibi&#65533;&#65533;o deve ser ajustada pois a o n&#65533;mero de frames n&#65533;o &#65533; a mesma que</span>
            <span class="comment">% a resolu&#65533;&#65533;o do integrador (TSPAN).</span>
            <span class="comment">%</span>

            TEMPO = 0:0.05:TOUT(end);

            <span class="comment">% Pre alocando as matrizes</span>
            rc1 = zeros(length(TEMPO),2);
            rc2 = zeros(length(TEMPO),2);
            rc3 = zeros(length(TEMPO),2);
            rc4 = zeros(length(TEMPO),2);

            efrente = zeros(length(TEMPO),2);
            etras = zeros(length(TEMPO),2);

            xxx = zeros(length(TEMPO),2);
            yyy = zeros(length(TEMPO),2);
            alphat = zeros(length(TEMPO),2);
            psii = zeros(length(TEMPO),2);

            alphaf = zeros(length(TEMPO),2);
            alphar = zeros(length(TEMPO),2);

            velf = zeros(length(TEMPO),2);
            velr = zeros(length(TEMPO),2);
            velt = zeros(length(TEMPO),2);

            rn1 = zeros(length(TEMPO),2);
            rn2 = zeros(length(TEMPO),2);
            rn3 = zeros(length(TEMPO),2);
            rn4 = zeros(length(TEMPO),2);

            <span class="keyword">for</span> i=1:length(TEMPO)
                <span class="comment">% Posi&#65533;&#65533;o dos cantos e eixo</span>
                rc1(i,1:2) = interp1(TOUT,rc1t,TEMPO(i));
                rc2(i,1:2) = interp1(TOUT,rc2t,TEMPO(i));
                rc3(i,1:2) = interp1(TOUT,rc3t,TEMPO(i));
                rc4(i,1:2) = interp1(TOUT,rc4t,TEMPO(i));

                efrente(i,1:2) = interp1(TOUT,ef,TEMPO(i));
                etras(i,1:2) = interp1(TOUT,er,TEMPO(i));

                <span class="comment">% Posi&#65533;&#65533;o do centro de massa</span>
                xxx(i,1:2) = interp1(TOUT,XT,TEMPO(i));
                yyy(i,1:2) = interp1(TOUT,YT,TEMPO(i));

                <span class="comment">% Estados</span>
                alphat(i,1:2) = interp1(TOUT,ALPHAT,TEMPO(i));
                psii(i,1:2) = interp1(TOUT,PSI,TEMPO(i));

                <span class="comment">% &#65533;ngulos de deriva</span>
                alphaf(i,1:2) = interp1(TOUT,ALPHAF,TEMPO(i));
                alphar(i,1:2) = interp1(TOUT,ALPHAR,TEMPO(i));

                <span class="comment">% Velocidade</span>
                velf(i,1:2) = interp1(TOUT,VF,TEMPO(i));
                velr(i,1:2) = interp1(TOUT,VR,TEMPO(i));
                velt(i,1:2) = interp1(TOUT,VT,TEMPO(i));
            <span class="keyword">end</span>

            <span class="comment">% Definindo a figura</span>
            <span class="comment">% Gerando a figura e definindo algumas propriedades</span>
            f=figure(666);
            set(f,<span class="string">'Units'</span>,<span class="string">'centimeters'</span>)
            set(f,<span class="string">'Position'</span>,[1 1 24 14])
            ax=gca();
            axis <span class="string">equal</span>
            set(ax,<span class="string">'NextPlot'</span>,<span class="string">'add'</span>,<span class="string">'Box'</span>,<span class="string">'on'</span>,<span class="string">'XGrid'</span>,<span class="string">'on'</span>,<span class="string">'YGrid'</span>,<span class="string">'on'</span>,<span class="string">'ZGrid'</span>,<span class="string">'on'</span>)
            set(ax,<span class="string">'XLim'</span>,[min(XT)-10 max(XT)+10])
            set(ax,<span class="string">'XLimMode'</span>,<span class="string">'manual'</span>)
            set(ax,<span class="string">'YLim'</span>,[min(YT)-10 max(YT)+10])
            set(ax,<span class="string">'YLimMode'</span>,<span class="string">'manual'</span>)

            <span class="comment">% Legendas</span>
            title(<span class="string">'Trajet\''oria'</span>,<span class="string">'Interpreter'</span>,<span class="string">'Latex'</span>)
            xlabel(<span class="string">'Dist\^ancia [m]'</span>,<span class="string">'Interpreter'</span>,<span class="string">'Latex'</span>);
            ylabel(<span class="string">'Dist\^ncia [m]'</span>,<span class="string">'Interpreter'</span>,<span class="string">'Latex'</span>);

            <span class="comment">% Primeiro frame</span>
            <span class="comment">%</span>
            <span class="comment">%</span>

            <span class="comment">% Vectores velocidade</span>
            <span class="comment">% Script "vector.m"</span>
            <span class="comment">% Escolhi n&#65533;o exibir o vector velocidade do centro de massa pq fica muito poluido</span>
            <span class="comment">%vector([xxx(1) yyy(1)],(alphat(1)+psii(1)),velt(1),'k');</span>
            self.Vector(efrente(1,1:2),(alphaf(1)+psii(1)),velf(1),<span class="string">'r'</span>);
            self.Vector(etras(1,1:2),(alphar(1)+psii(1)),velr(1),<span class="string">'g'</span>);

            <span class="comment">% Coordenadas dos cantos para o primeiro frame</span>
            xc = [rc1(1,1) rc2(1,1) rc3(1,1) rc4(1,1)];
            yc = [rc1(1,2) rc2(1,2) rc3(1,2) rc4(1,2)];

            <span class="comment">% Exibindo o ve&#65533;culo</span>
            fill(xc,yc,<span class="string">'r'</span>)

            <span class="comment">% Adding semitrailer</span>
            <span class="keyword">if</span> col == 8
                PHI = XOUT(:,7);        <span class="comment">% Orienta&#65533;&#65533;o relativa do semirreboque [rad]</span>
                dPHI = XOUT(:,8);       <span class="comment">% Velocidade angular relativa entre as unidades [rad/s]</span>

                c = self.vehicle.distRA;        <span class="comment">% distancia da articula&#65533;&#65533;o ao centro de massa do caminh&#65533;o-trator [m]</span>
                d = self.vehicle.distAS;        <span class="comment">% distancia do eixo traseiro ao centro de massa do caminh&#65533;o-trator [m]</span>
                e = self.vehicle.distSM;        <span class="comment">% distancia da articula&#65533;&#65533;o ao centro de massa do caminh&#65533;o-trator [m]</span>
                lS = self.vehicle.widthSemi / 2;              <span class="comment">% Metade da width do vehicle [m]</span>

                <span class="comment">% &#65533;ngulo de deriva no eixo do semirreboque [rad]</span>
                ALPHAM = atan2(((d + e)*(dPHI - dPSI) + VT.*sin(ALPHAT + PHI) - b*dPSI.*cos(PHI) - c*dPSI.*cos(PHI)),(VT.*cos(ALPHAT + PHI) + b*dPSI.*sin(PHI) + c*dPSI.*sin(PHI)));
                <span class="comment">% M&#65533;dulo da velocidade no eixo do semirreboque [m/s]</span>
                VM = sqrt((VT.*cos(ALPHAT + PHI) + b*dPSI.*sin(PHI) + c*dPSI.*sin(PHI)).^2 + ((d + e)*(dPHI - dPSI) + VT.*sin(ALPHAT + PHI) - b*dPSI.*cos(PHI) - c*dPSI.*cos(PHI)).^2);
                RS = [XT-(b+c)*cos(PSI)-d*cos(PSI-PHI) YT-(b+c)*sin(PSI)-d*sin(PSI-PHI)];
                <span class="comment">% Vectores posi&#65533;&#65533;o 1, 2, 3 e 4 em rela&#65533;&#65533;o a S na base (S s1 s2 s3)</span>
                rs1s = [d;lS];           <span class="comment">% dianteira esquerda</span>
                rs2s = [d;-lS];          <span class="comment">% dianteira direita</span>
                rs3s = [-e;-lS];         <span class="comment">% traseira direita</span>
                rs4s = [-e;lS];          <span class="comment">% traseira esquerda</span>

                eim = [-e;0];           <span class="comment">% Posicao do eixo do semirreboque</span>

                rn1i = zeros(length(TOUT),2);
                rn2i = zeros(length(TOUT),2);
                rn3i = zeros(length(TOUT),2);
                rn4i = zeros(length(TOUT),2);

                emm = zeros(length(TOUT),2);

                <span class="keyword">for</span> j=1:length(TOUT)
                    <span class="comment">% Matriz de rota&#65533;&#65533;o da base (S s1 s2 s3) para (o i j k)</span>
                    RSI=[cos(PSI(j)-PHI(j)) -sin(PSI(j)-PHI(j));sin(PSI(j)-PHI(j)) cos(PSI(j)-PHI(j))];
                    <span class="comment">% Vectores posi&#65533;&#65533;o 1, 2, 3 e 4 em rela&#65533;&#65533;o a O na base (c c1 c2 c3)</span>
                    rn1i(j,1:2) = (RSI*rs1s)';
                    rn2i(j,1:2) = (RSI*rs2s)';
                    rn3i(j,1:2) = (RSI*rs3s)';
                    rn4i(j,1:2) = (RSI*rs4s)';

                    <span class="comment">% Posicionando o eixo dianteiro e o traseiro</span>
                    emm(j,1:2) = (RSI*eim);     <span class="comment">% Eixo trasiro</span>
                <span class="keyword">end</span>

                <span class="comment">% Vectores posi&#65533;&#65533;o 1, 2, 3 e 4 em rela&#65533;&#65533;o a o na base (o i j k)</span>
                rn1t=RS+rn1i;
                rn2t=RS+rn2i;
                rn3t=RS+rn3i;
                rn4t=RS+rn4i;

                em = RS+emm;

                phii = zeros(length(TEMPO),2);
                alpham = zeros(length(TEMPO),2);
                velm = zeros(length(TEMPO),2);
                emsemi = zeros(length(TEMPO),2);

                <span class="keyword">for</span> i=1:length(TEMPO)
                    phii(i,1:2) = interp1(TOUT,PHI,TEMPO(i));
                    alpham(i,1:2) = interp1(TOUT,ALPHAM,TEMPO(i));
                    velm(i,1:2) = interp1(TOUT,VM,TEMPO(i));
                    <span class="comment">% Semirreboque</span>
                    rn1(i,1:2) = interp1(TOUT,rn1t,TEMPO(i));
                    rn2(i,1:2) = interp1(TOUT,rn2t,TEMPO(i));
                    rn3(i,1:2) = interp1(TOUT,rn3t,TEMPO(i));
                    rn4(i,1:2) = interp1(TOUT,rn4t,TEMPO(i));

                    emsemi(i,1:2) = interp1(TOUT,em,TEMPO(i));
                <span class="keyword">end</span>

                self.Vector(emsemi(1,1:2),(alpham(1)+psii(1)-phii(1)),velm(1),<span class="string">'b'</span>);
                xn = [rn1(1,1) rn2(1,1) rn3(1,1) rn4(1,1)];
                yn = [rn1(1,2) rn2(1,2) rn3(1,2) rn4(1,2)];
                fill(xn,yn,<span class="string">'g'</span>)
            <span class="keyword">end</span>


            <span class="keyword">if</span> saveit == 1
                <span class="comment">% Inicializando o gif</span>
                frame = getframe(666);
                im = frame2im(frame);
                [A,map] = rgb2ind(im,256,<span class="string">'nodither'</span>);
                imwrite(A,map,<span class="string">'Animacao.gif'</span>,<span class="string">'LoopCount'</span>,Inf,<span class="string">'DelayTime'</span>,0.05);
            <span class="keyword">end</span>

            <span class="comment">% Frames restantes</span>
            <span class="comment">%</span>
            <span class="keyword">for</span> j = 1:length(TEMPO)
                <span class="comment">% Trajet&#65533;ria do centro de massa</span>

                <span class="comment">% Centro de massa (Comentado porque n&#65533;o sei se vou usar)</span>
                <span class="comment">% plot(XT,YT,'r')</span>
                <span class="comment">% plot(RS(:,1),RS(:,2),'g')</span>

                <span class="comment">% Eixos</span>
                plot(efrente(:,1),efrente(:,2),<span class="string">'r'</span>)
                plot(etras(:,1),etras(:,2),<span class="string">'g'</span>)

                <span class="comment">% Coordenadas dos cantos para os frames</span>
                xc = [rc1(j,1) rc2(j,1) rc3(j,1) rc4(j,1)];
                yc = [rc1(j,2) rc2(j,2) rc3(j,2) rc4(j,2)];


                <span class="comment">% Exibindo o ve&#65533;culo</span>
                fill(xc,yc,<span class="string">'r'</span>)

                <span class="comment">% Vectores velocidade</span>
                <span class="comment">% Com cores diferentes</span>
                <span class="comment">% Escolhi n&#65533;o exibir o vector velocidade do centro de massa pq fica muito poluido</span>
                <span class="comment">%vector([xxx(j) yyy(j)],(alphat(j)+psii(j)),velt(j),'k');</span>
                self.Vector(efrente(j,1:2),(alphaf(j)+psii(j)),velf(j),<span class="string">'r'</span>);
                self.Vector(etras(j,1:2),(alphar(j)+psii(j)),velr(j),<span class="string">'g'</span>);

                <span class="keyword">if</span> col == 8
                    plot(emsemi(:,1),emsemi(:,2),<span class="string">'b'</span>)
                    xn = [rn1(j,1) rn2(j,1) rn3(j,1) rn4(j,1)];
                    yn = [rn1(j,2) rn2(j,2) rn3(j,2) rn4(j,2)];
                    fill(xn,yn,<span class="string">'g'</span>)
                    self.Vector(emsemi(j,1:2),(alpham(j)+psii(j)-phii(j)),velm(j),<span class="string">'b'</span>);
                <span class="keyword">end</span>

                <span class="keyword">if</span> saveit == 1
                    <span class="comment">% Adicionando o frame atual ao gif iniciado</span>
                    frame = getframe(666);
                    im = frame2im(frame);
                    [A,map] = rgb2ind(im,256,<span class="string">'nodither'</span>);
                    imwrite(A,map,<span class="string">'Animacao.gif'</span>,<span class="string">'WriteMode'</span>,<span class="string">'append'</span>,<span class="string">'DelayTime'</span>,0.05);
                <span class="keyword">end</span>
                <span class="comment">% Pausa a exibi&#65533;&#65533;o - ATEN&#65533;&#65533;O: Tem que ser o mesmo valor usado no ajuste</span>
                <span class="comment">% do tempo</span>

                pause(0.05)

                cla(ax); <span class="comment">% Limpando o axes</span>
            <span class="keyword">end</span>

            <span class="comment">% &#65533;ltimo frame</span>
            <span class="comment">% A &#65533;ltima imagem que a figura vai exibir quando a anima&#65533;&#65533;o acabar</span>
            <span class="comment">%</span>

            <span class="comment">% Eixos</span>
            plot(efrente(:,1),efrente(:,2),<span class="string">'r'</span>)
            plot(etras(:,1),etras(:,2),<span class="string">'g'</span>)

            <span class="comment">% Coordenadas dos cantos para o &#65533;ltimo frame</span>
            xc = [rc1(end,1) rc2(end,1) rc3(end,1) rc4(end,1)];
            yc = [rc1(end,2) rc2(end,2) rc3(end,2) rc4(end,2)];

            <span class="comment">% Exibindo o ve&#65533;culo</span>
            fill(xc,yc,<span class="string">'r'</span>)

            <span class="comment">% Escolhi n&#65533;o exibir o vector velocidade do centro de massa pq fica muito poluido</span>
            <span class="comment">%vector([xxx(end) yyy(end)],(alphat(end)+psii(end)),velt(end),'k');</span>
            self.Vector(efrente(end,1:2),(alphaf(end)+psii(end)),velf(end),<span class="string">'r'</span>);
            self.Vector(etras(end,1:2),(alphar(end)+psii(end)),velr(end),<span class="string">'g'</span>);

            <span class="comment">% Incluindo o semirreboque</span>
            <span class="keyword">if</span> col == 8
                plot(emsemi(:,1),emsemi(:,2),<span class="string">'b'</span>)
                xn = [rn1(end,1) rn2(end,1) rn3(end,1) rn4(end,1)];
                yn = [rn1(end,2) rn2(end,2) rn3(end,2) rn4(end,2)];
                fill(xn,yn,<span class="string">'g'</span>)
                self.Vector(emsemi(end,1:2),(alpham(end)+psii(end)-phii(end)),velm(end),<span class="string">'b'</span>);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><h2>Frame<a name="5"></a></h2><p>Plots the sequence of frames of the vehicle manoever.</p><p><b>Sintax</b></p><p><tt><i>GraphicsClass</i>.Frame(XOUT,TOUT,saveit)</tt></p><p><b>Arguments</b></p><p>The following table describes the input arguments:</p><p> <table border=1 width="97%">
<tr> <td width="30%"><tt>XOUT</tt></td> <td width="70%">Solution array. Each column corresponds to the solution of each state variable of the vehicle. The columns must respect the following variable order: [XT YT PSI dPSI VT ALPHAT (PHI dPHI)] </td> </tr>
<tr> <td width="30%"><tt>TOUT</tt></td> <td width="70%">Column vector of time points.</td> </tr>
<tr> <td width="30%"><tt>saveit</tt></td> <td width="70%">Flag for saving the trajectory image in a pdf file. If savit = 0 the image will not be saved. If savit = 1 a file Trajetoria.pdf is generated.</td> </tr>
</table> </p><p><b>Description</b></p><p>TEXTO</p><pre class="codeinput">        <span class="keyword">function</span> Frame(self,XOUT,TOUT,saveit)
            <span class="comment">% Verificando quantidade de colunas para saber se &#65533; ve&#65533;culo simples ou articulado</span>
            <span class="comment">% col = 6 -&gt; simples</span>
            <span class="comment">% col = 8 -&gt; articulado</span>
            [col] = size(XOUT,2);

            <span class="comment">% States</span>
            XT = XOUT(:,1);                 <span class="comment">% Horizontal position [m]</span>
            YT = XOUT(:,2);                 <span class="comment">% Vertical position [m]</span>
            PSI = XOUT(:,3);                <span class="comment">% Vehicle yaw angle [rad]</span>
            dPSI = XOUT(:,4);               <span class="comment">% Yaw rate [rad/s]</span>
            VT = XOUT(:,5);                 <span class="comment">% Vehicle CG velocity [m/s]</span>
            ALPHAT = XOUT(:,6);             <span class="comment">% Vehicle side slip angle [rad]</span>

            <span class="comment">% Distances</span>
            a = self.vehicle.distFT;        <span class="comment">% Distance FT [m]</span>
            b = self.vehicle.distTR;        <span class="comment">% Distance TR [m]</span>
            lT = self.vehicle.width / 2;  <span class="comment">% Metade da width do vehicle [m]</span>

            <span class="comment">% Slip angles</span>
            ALPHAF = atan2((a*dPSI + VT.*sin(ALPHAT)),(VT.*cos(ALPHAT)));   <span class="comment">% Front [rad]</span>
            <span class="comment">% OBS: N&#65533;o tem o delta pq &#65533; pra medir o &#65533;ngulo entre o vector velocidade do eixo dianteiro e o plano longitudinal do ve&#65533;culo</span>
            ALPHAR = atan2((-b*dPSI + VT.*sin(ALPHAT)),(VT.*cos(ALPHAT)));  <span class="comment">% Rear [rad]</span>

            <span class="comment">%</span>
            <span class="comment">% OBS: Calculando os &#65533;ngulos de deriva com "atan2", quando o valor chega a</span>
            <span class="comment">% 180 graus fica estranho o vector.</span>
            <span class="comment">%</span>
            <span class="comment">% Velocity</span>
            VF = sqrt((VT.*cos(ALPHAT)).^2 + (a*dPSI + VT.*sin(ALPHAT)).^2);    <span class="comment">% Front [m/s]</span>
            VR = sqrt((VT.*cos(ALPHAT)).^2 + (-b*dPSI + VT.*sin(ALPHAT)).^2);   <span class="comment">% Rear [m/s]</span>

            <span class="comment">% Posi&#65533;&#65533;o relativa dos cantos e eixos</span>
            <span class="comment">% Determina a posi&#65533;&#65533;o dos cantos e eixos do ve&#65533;culo com rela&#65533;&#65533;o ao centro</span>
            <span class="comment">% de massa.</span>
            <span class="comment">% Vectores posi&#65533;&#65533;o 1, 2, 3 e 4 em rela&#65533;&#65533;o a T na base (T t1 t2 t3)</span>
            rt1t = [a;lT];           <span class="comment">% dianteira esquerda</span>
            rt2t = [a;-lT];          <span class="comment">% dianteira direita</span>
            rt3t = [-b;-lT];         <span class="comment">% traseira direita</span>
            rt4t = [-b;lT];          <span class="comment">% traseira esquerda</span>

            eif = [a;0];            <span class="comment">% Posicao do eixo dianteiro</span>
            eir = [-b;0];           <span class="comment">% Posicao do eixo trasiero</span>

            <span class="comment">% Pre alocando</span>
            rt1i = zeros(length(TOUT),2);
            rt2i = zeros(length(TOUT),2);
            rt3i = zeros(length(TOUT),2);
            rt4i = zeros(length(TOUT),2);

            eff = zeros(length(TOUT),2);
            err = zeros(length(TOUT),2);

            <span class="comment">% Evolu&#65533;&#65533;o da posi&#65533;&#65533;o absoluta dos cantos e eixos</span>
            <span class="comment">% Determina a movimenta&#65533;&#65533;o dos pontos devido a mudan&#65533;a de orienta&#65533;&#65533;o do</span>
            <span class="comment">% ve&#65533;culo.</span>
            <span class="keyword">for</span> j=1:length(TOUT)
                <span class="comment">% Matriz de rota&#65533;&#65533;o da base (T t1 t2 t3) para (o i j k)</span>
                RTI=[cos(PSI(j)) -sin(PSI(j));sin(PSI(j)) cos(PSI(j))];
                <span class="comment">% Vectores posi&#65533;&#65533;o 1, 2, 3 e 4 em rela&#65533;&#65533;o a origem do ref inercial na</span>
                <span class="comment">% base (T t1 t2 t3)</span>
                rt1i(j,1:2) = (RTI*rt1t)';
                rt2i(j,1:2) = (RTI*rt2t)';
                rt3i(j,1:2) = (RTI*rt3t)';
                rt4i(j,1:2) = (RTI*rt4t)';
                <span class="comment">% Posicionando o eixo dianteiro e o traseiro</span>
                eff(j,1:2) = (RTI*eif);     <span class="comment">% Eixo dianteiro</span>
                err(j,1:2) = (RTI*eir);     <span class="comment">% Eixo trasiro</span>
            <span class="keyword">end</span>

            <span class="comment">% Posi&#65533;&#65533;o absoluta dos cantos e eixos</span>
            <span class="comment">% A evolu&#65533;&#65533;o da posi&#65533;&#65533;o absoluta dos pontos ao longo do tempo.</span>
            <span class="comment">% Vectores posi&#65533;&#65533;o 1, 2, 3 e 4 em rela&#65533;&#65533;o a o na base (o i j k)</span>
            rc1t=[XT YT]+rt1i;
            rc2t=[XT YT]+rt2i;
            rc3t=[XT YT]+rt3i;
            rc4t=[XT YT]+rt4i;
            <span class="comment">% Posicionamento absoluto do eixo dianteiro e trasiero</span>
            ef = [XT YT]+eff;
            er = [XT YT]+err;

            <span class="comment">% Ajuste do tempo</span>
            <span class="comment">% A exibi&#65533;&#65533;o deve ser ajustada pois a o n&#65533;mero de frames n&#65533;o &#65533; a mesma que</span>
            <span class="comment">% a resolu&#65533;&#65533;o do integrador (TSPAN).</span>
            <span class="comment">%</span>
            <span class="comment">% A vari&#65533;vel tempo define em que instantes o ve&#65533;culo vai ser plotado</span>
            TEMPO = 0:1:TOUT(end);

            <span class="comment">% Pre alocando as matrizes</span>
            rc1 = zeros(length(TEMPO),2);
            rc2 = zeros(length(TEMPO),2);
            rc3 = zeros(length(TEMPO),2);
            rc4 = zeros(length(TEMPO),2);

            efrente = zeros(length(TEMPO),2);
            etras = zeros(length(TEMPO),2);

            xxx = zeros(length(TEMPO),2);
            yyy = zeros(length(TEMPO),2);
            alphat = zeros(length(TEMPO),2);
            psii = zeros(length(TEMPO),2);

            alphaf = zeros(length(TEMPO),2);
            alphar = zeros(length(TEMPO),2);

            velf = zeros(length(TEMPO),2);
            velr = zeros(length(TEMPO),2);
            velt = zeros(length(TEMPO),2);

            <span class="keyword">for</span> i=1:length(TEMPO)
                <span class="comment">% Posi&#65533;&#65533;o dos cantos e eixo</span>
                rc1(i,1:2) = interp1(TOUT,rc1t,TEMPO(i));
                rc2(i,1:2) = interp1(TOUT,rc2t,TEMPO(i));
                rc3(i,1:2) = interp1(TOUT,rc3t,TEMPO(i));
                rc4(i,1:2) = interp1(TOUT,rc4t,TEMPO(i));
                <span class="comment">% Posi&#65533;&#65533;o do centro de massa</span>
                xxx(i,1:2) = interp1(TOUT,XT,TEMPO(i));
                yyy(i,1:2) = interp1(TOUT,YT,TEMPO(i));
                <span class="comment">% Estados</span>
                alphat(i,1:2) = interp1(TOUT,ALPHAT,TEMPO(i));
                psii(i,1:2) = interp1(TOUT,PSI,TEMPO(i));
                <span class="comment">% &#65533;ngulos de deriva</span>
                alphaf(i,1:2) = interp1(TOUT,ALPHAF,TEMPO(i));
                alphar(i,1:2) = interp1(TOUT,ALPHAR,TEMPO(i));
                <span class="comment">% Velocidade</span>
                velf(i,1:2) = interp1(TOUT,VF,TEMPO(i));
                velr(i,1:2) = interp1(TOUT,VR,TEMPO(i));
                velt(i,1:2) = interp1(TOUT,VT,TEMPO(i));
            <span class="keyword">end</span>

            <span class="comment">% Definindo a figura</span>
            <span class="comment">% Gerando a figura e definindo algumas propriedades</span>
            <span class="comment">%</span>
            f999 = figure(999);
            set(f999,<span class="string">'Units'</span>,<span class="string">'centimeters'</span>)
            set(f999,<span class="string">'Position'</span>,[1 1 24 14])
            set(f999,<span class="string">'PaperUnits'</span>,<span class="string">'centimeters'</span>)
            set(f999,<span class="string">'PaperPosition'</span>,[5 0 16 12])
            PaperPos = get(f999,<span class="string">'PaperPosition'</span>);
            set(f999,<span class="string">'PaperSize'</span>,PaperPos(3:4))
            ax999=gca();
            set(ax999,<span class="string">'NextPlot'</span>,<span class="string">'add'</span>,<span class="string">'Box'</span>,<span class="string">'on'</span>,<span class="string">'XGrid'</span>,<span class="string">'on'</span>,<span class="string">'YGrid'</span>,<span class="string">'on'</span>,<span class="string">'ZGrid'</span>,<span class="string">'on'</span>)
            axis <span class="string">equal</span>
            set(ax999,<span class="string">'XLim'</span>,[min(XT)-20 max(XT)+10])
            set(ax999,<span class="string">'XLimMode'</span>,<span class="string">'manual'</span>)
            set(ax999,<span class="string">'YLim'</span>,[min(YT)-10 max(YT)+10])
            set(ax999,<span class="string">'YLimMode'</span>,<span class="string">'manual'</span>)

            xlabel(<span class="string">'Dist\^ancia [m]'</span>,<span class="string">'Interpreter'</span>,<span class="string">'Latex'</span>)
            ylabel(<span class="string">'Dist\^ancia [m]'</span>,<span class="string">'Interpreter'</span>,<span class="string">'Latex'</span>)

            TEMPOplot = 0:0.05:TOUT(end); <span class="comment">% Tempo para os plot da curva de trajet&#65533;ria</span>
            <span class="keyword">for</span> i=1:length(TEMPOplot)
                efrente(i,1:2) = interp1(TOUT,ef,TEMPOplot(i));
                etras(i,1:2) = interp1(TOUT,er,TEMPOplot(i));
            <span class="keyword">end</span>

            <span class="comment">% plot(efrente(:,1),efrente(:,2),'r')</span>
            <span class="comment">% plot(etras(:,1),etras(:,2),'g')</span>
            plot(ef(:,1),ef(:,2),<span class="string">'r'</span>)
            plot(er(:,1),er(:,2),<span class="string">'g'</span>)

            <span class="keyword">for</span> j = 1:length(TEMPO)
                <span class="comment">% Coordenadas dos cantos para os frames</span>
                xc = [rc1(j,1) rc2(j,1) rc3(j,1) rc4(j,1)];
                yc = [rc1(j,2) rc2(j,2) rc3(j,2) rc4(j,2)];
                <span class="comment">% Exibindo o ve&#65533;culo</span>
                fill(xc,yc,<span class="string">'r'</span>);
            <span class="keyword">end</span>

            <span class="comment">% Adding semitrailer</span>
            <span class="keyword">if</span> col == 8
                PHI = XOUT(:,7);        <span class="comment">% Orienta&#65533;&#65533;o relativa do semirreboque [rad]</span>
                dPHI = XOUT(:,8);       <span class="comment">% Velocidade angular relativa entre as unidades [rad/s]</span>

                c = self.vehicle.distRA;        <span class="comment">% distancia da articula&#65533;&#65533;o ao centro de massa do caminh&#65533;o-trator [m]</span>
                d = self.vehicle.distAS;        <span class="comment">% distancia do eixo traseiro ao centro de massa do caminh&#65533;o-trator [m]</span>
                e = self.vehicle.distSM;        <span class="comment">% distancia da articula&#65533;&#65533;o ao centro de massa do caminh&#65533;o-trator [m]</span>
                lS = self.vehicle.widthSemi / 2;              <span class="comment">% Metade da width do vehicle [m]</span>
                <span class="comment">% &#65533;ngulo de deriva no eixo do semirreboque [rad]</span>
                ALPHAM = atan2(((d + e)*(dPHI - dPSI) + VT.*sin(ALPHAT + PHI) - b*dPSI.*cos(PHI) - c*dPSI.*cos(PHI)),(VT.*cos(ALPHAT + PHI) + b*dPSI.*sin(PHI) + c*dPSI.*sin(PHI)));
                <span class="comment">% M&#65533;dulo da velocidade no eixo do semirreboque [m/s]</span>
                VM = sqrt((VT.*cos(ALPHAT + PHI) + b*dPSI.*sin(PHI) + c*dPSI.*sin(PHI)).^2 + ((d + e)*(dPHI - dPSI) + VT.*sin(ALPHAT + PHI) - b*dPSI.*cos(PHI) - c*dPSI.*cos(PHI)).^2);
                <span class="comment">% Posi&#65533;&#65533;o do centro de massa do semirreboque</span>
                RS = [XT-(b+c)*cos(PSI)-d*cos(PSI-PHI) YT-(b+c)*sin(PSI)-d*sin(PSI-PHI)];
                <span class="comment">% Vectores posi&#65533;&#65533;o 1, 2, 3 e 4 em rela&#65533;&#65533;o a S na base (S s1 s2 s3)</span>
                rs1s = [d;lS];           <span class="comment">% dianteira esquerda</span>
                rs2s = [d;-lS];          <span class="comment">% dianteira direita</span>
                rs3s = [-e;-lS];         <span class="comment">% traseira direita</span>
                rs4s = [-e;lS];          <span class="comment">% traseira esquerda</span>
                eim = [-e;0];           <span class="comment">% Posicao do eixo do semirreboque</span>
                <span class="comment">% Pre alocando</span>
                rn1i = zeros(length(TOUT),2);
                rn2i = zeros(length(TOUT),2);
                rn3i = zeros(length(TOUT),2);
                rn4i = zeros(length(TOUT),2);
                emm = zeros(length(TOUT),2);

                <span class="keyword">for</span> j=1:length(TOUT)
                    <span class="comment">% Matriz de rota&#65533;&#65533;o da base (S s1 s2 s3) para (o i j k)</span>
                    RSI=[cos(PSI(j)-PHI(j)) -sin(PSI(j)-PHI(j));sin(PSI(j)-PHI(j)) cos(PSI(j)-PHI(j))];
                    <span class="comment">% Vectores posi&#65533;&#65533;o 1, 2, 3 e 4 em rela&#65533;&#65533;o a O na base (c c1 c2 c3)</span>
                    rn1i(j,1:2) = (RSI*rs1s)';
                    rn2i(j,1:2) = (RSI*rs2s)';
                    rn3i(j,1:2) = (RSI*rs3s)';
                    rn4i(j,1:2) = (RSI*rs4s)';
                    <span class="comment">% Posicionando o eixo dianteiro e o traseiro</span>
                    emm(j,1:2) = (RSI*eim);     <span class="comment">% Eixo trasiro</span>
                <span class="keyword">end</span>
                <span class="comment">% Vectores posi&#65533;&#65533;o 1, 2, 3 e 4 em rela&#65533;&#65533;o a o na base (o i j k)</span>
                rn1t=RS+rn1i;
                rn2t=RS+rn2i;
                rn3t=RS+rn3i;
                rn4t=RS+rn4i;

                em = RS+emm;

                phii = zeros(length(TEMPO),2);
                alpham = zeros(length(TEMPO),2);
                velm = zeros(length(TEMPO),2);
                rn1 = zeros(length(TEMPO),2);
                rn2 = zeros(length(TEMPO),2);
                rn3 = zeros(length(TEMPO),2);
                rn4 = zeros(length(TEMPO),2);
                emsemi = zeros(length(TEMPO),2);

                <span class="keyword">for</span> i=1:length(TEMPO)
                    phii(i,1:2) = interp1(TOUT,PHI,TEMPO(i));
                    alpham(i,1:2) = interp1(TOUT,ALPHAM,TEMPO(i));
                    velm(i,1:2) = interp1(TOUT,VM,TEMPO(i));

                    rn1(i,1:2) = interp1(TOUT,rn1t,TEMPO(i));
                    rn2(i,1:2) = interp1(TOUT,rn2t,TEMPO(i));
                    rn3(i,1:2) = interp1(TOUT,rn3t,TEMPO(i));
                    rn4(i,1:2) = interp1(TOUT,rn4t,TEMPO(i));
                <span class="keyword">end</span>
                <span class="keyword">for</span> i=1:length(TEMPOplot)
                    emsemi(i,1:2) = interp1(TOUT,em,TEMPOplot(i));
                <span class="keyword">end</span>
                plot(em(:,1),em(:,2),<span class="string">'b'</span>)
                <span class="comment">% plot(emsemi(:,1),emsemi(:,2),'b')</span>

                <span class="keyword">for</span> j = 1:length(TEMPO)
                    xn = [rn1(j,1) rn2(j,1) rn3(j,1) rn4(j,1)];
                    yn = [rn1(j,2) rn2(j,2) rn3(j,2) rn4(j,2)];
                    fill(xn,yn,<span class="string">'g'</span>);
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> saveit == 1
                print(f999,<span class="string">'-dpdf'</span>,<span class="string">'Trajetoria.pdf'</span>)
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>

    methods(Static)
</pre><h2>Vector<a name="8"></a></h2><p>Plots a vector arrow.</p><p><b>Sintax</b></p><p><tt><i>GraphicsClass</i>.Vector(inicio,angulo,modulo,cor)</tt></p><p><b>Arguments</b></p><p>The following table describes the input arguments:</p><p> <table border=1 width="97%">
<tr> <td width="30%"><tt>inicio</tt></td> <td width="70%">Coordenada do �nicio da flecha.</td> </tr>
<tr> <td width="30%"><tt>angulo</tt></td> <td width="70%">�ngulo da orienta��o da flecha.</td> </tr>
<tr> <td width="30%"><tt>M�dulo</tt></td> <td width="70%">Comprimento da flecha.</td> </tr>
<tr> <td width="30%"><tt>cor</tt></td> <td width="70%">Cor da flecha.</td> </tr>
</table> </p><p><b>Description</b></p><p>TEXTO</p><pre class="codeinput">        <span class="keyword">function</span> Vector(inicio,angulo,modulo,cor)
            coord1 = inicio;                                    <span class="comment">% inicio do vector</span>
            theta = angulo;
            modulo = 0.7*modulo;                                <span class="comment">% modulo do vector</span>
            coord2 = modulo*[cos(theta) sin(theta)] + coord1;   <span class="comment">% fim do vector</span>

            <span class="comment">%theta = atan2((coord1(1)-coord2(1)),(coord1(2)-coord2(2))); % angulo de orienta&#65533;&#65533;o do triangulo</span>
            esc = 1; <span class="comment">% Escala</span>
            l = 0.5; <span class="comment">% width relativa em rela&#65533;&#65533;o ao comprimento do triangulo (0-1)</span>

            <span class="comment">% Forma e orienta&#65533;&#65533;o do triangulo</span>
            c1 = esc*l*[-sin(theta) +cos(theta)];   <span class="comment">% canto 1 - inferior esquerdo</span>
            c2 = esc*l*[+sin(theta) -cos(theta)];   <span class="comment">% canto 2 - inferior direito</span>
            c3 = esc*[+cos(theta) +sin(theta)];     <span class="comment">% canto 3 - superior central</span>

            <span class="comment">% Escala e posicionamento</span>
            x = [c1(1)+coord2(1) c2(1)+coord2(1) c3(1)+coord2(1)];
            y = [c1(2)+coord2(2) c2(2)+coord2(2) c3(2)+coord2(2)];

            <span class="comment">% figure(1)</span>
            <span class="comment">% axis equal</span>
            hold <span class="string">on</span>
            fill(x,y,cor)
            p = plot([coord1(1) coord2(1)],[coord1(2) coord2(2)],cor);
            set(p,<span class="string">'LineWidth'</span>,2)
            <span class="comment">% Id&#65533;ia de colocar um marcador no in&#65533;cio do vector</span>
            <span class="comment">% m = plot(coord1(1),coord1(2),strcat('*',cor));</span>
            <span class="comment">% set(m,'MarkerSize',10)</span>
        <span class="keyword">end</span>
</pre><h2>changeMarker<a name="9"></a></h2><p>A fun&#65533;&#65533;o changeMarker altera o n&#65533;mero de marcadores num plot.</p><p><b>Sintax</b></p><p><tt><i>GraphicsClass</i>.changeMarker(p,n)</tt></p><p><b>Arguments</b></p><p>The following table describes the input arguments:</p><p> <table border=1 width="97%">
<tr> <td width="30%"><tt>p</tt></td> <td width="70%">Handle do plot.</td> </tr>
<tr> <td width="30%"><tt>n</tt></td> <td width="70%">N�mero de marcadores que devem ser exibidos.</td> </tr>
</table> </p><p><b>Description</b></p><p>TEXTO</p><pre class="codeinput">        <span class="keyword">function</span> changeMarker(p,n)
            <span class="comment">% p - handle of plot</span>
            <span class="comment">% n - number of markers</span>

            <span class="comment">% Line info</span>
            line_color = get(p,<span class="string">'Color'</span>);
            line_Style = get(p,<span class="string">'LineStyle'</span>);
            line_LineWidth = get(p,<span class="string">'LineWidth'</span>);
            <span class="comment">% Marker info</span>
            marker_type = get(p,<span class="string">'Marker'</span>);
            marker_size = get(p,<span class="string">'MarkerSize'</span>);
            marker_EdgeColor = get(p,<span class="string">'MarkerEdgeColor'</span>);
            marker_FaceColor = get(p,<span class="string">'MarkerFaceColor'</span>);
            <span class="comment">% Axis info</span>
            vec_XData = get(p,<span class="string">'XData'</span>);
            vec_YData = get(p,<span class="string">'YData'</span>);

            size_XData = length(vec_XData);

            step = floor((size_XData)/(n-1));

            <span class="comment">% Fazendo o plot dos marcadores</span>
            p_marker = plot(vec_XData(1:step:end),vec_YData(1:step:end));
            set(p_marker,<span class="string">'LineStyle'</span>,<span class="string">'none'</span>,<span class="string">'Marker'</span>,marker_type,<span class="string">'MarkerSize'</span>,marker_size,<span class="keyword">...</span>
            	<span class="string">'MarkerEdgeColor'</span>,marker_EdgeColor,<span class="string">'MarkerFaceColor'</span>,marker_FaceColor)

            <span class="comment">% Removendo o marcador do plot original</span>
            set(p,<span class="string">'Marker'</span>,<span class="string">'none'</span>)
            <span class="comment">% Remover a visibilidade do handle do original e do marcador</span>
            set(p,<span class="string">'HandleVisibility'</span>,<span class="string">'off'</span>)
            set(p_marker,<span class="string">'HandleVisibility'</span>,<span class="string">'off'</span>)

            <span class="comment">% Dummy para legenda</span>
            p_dummy = plot(vec_XData(1),vec_YData(1));
            set(p_dummy,<span class="string">'Color'</span>,line_color,<span class="string">'LineStyle'</span>,line_Style,<span class="string">'LineWidth'</span>,line_LineWidth,<span class="keyword">...</span>
            	<span class="string">'Marker'</span>,marker_type,<span class="string">'MarkerSize'</span>,marker_size,<span class="keyword">...</span>
            	<span class="string">'MarkerEdgeColor'</span>,marker_EdgeColor,<span class="string">'MarkerFaceColor'</span>,marker_FaceColor)
        <span class="keyword">end</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>
</pre><h2>Properties<a name="11"></a></h2><pre class="codeinput">    properties
        vehicle
    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><h2>See Also<a name="13"></a></h2><p><a href="index.html">Index</a></p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2013a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Graphics
% Functions for graphics generation.
%
%% Code
%

classdef Graphics
	methods
        % Constructor
        function self = Graphics(varargin)
            v = VehicleDynamics.VehicleArticulatedNonlinear4DOF;
            if nargin == 0
                self.vehicle = v;%.params;
            else
                self.vehicle = varargin{1};%.params;
            end
        end

        %% Animation
        % Animates the manoever.
        %
        % *Sintax*
        %
        % |_GraphicsClass_.Animation(XOUT,TOUT,saveit)|
        %
        % *Arguments*
        %
        % The following table describes the input arguments:
        %
        % <html> <table border=1 width="97%">
        % <tr> <td width="30%"><tt>XOUT</tt></td> <td width="70%">Solution array. Each column corresponds to the solution of each state variable of the vehicle. The columns must respect the following variable order: [XT YT PSI dPSI VT ALPHAT (PHI dPHI)] </td> </tr>
        % <tr> <td width="30%"><tt>TOUT</tt></td> <td width="70%">Column vector of time points.</td> </tr>
        % <tr> <td width="30%"><tt>saveit</tt></td> <td width="70%">Flag for saving the animation in a gif file. If savit = 0 the animation will not be saved. If savit = 1 a file Animacao.gif is generated.</td> </tr>
        % </table> </html>
        %
        % *Description*
        %
        % TEXT

        function Animation(self,XOUT,TOUT,saveit)
            % Verificando quantidade de colunas para saber se � ve�culo simples ou articulado
            % col = 6 -> simples
            % col = 8 -> articulado
            [col] = size(XOUT,2);

            % States
            XT = XOUT(:,1);                 % Horizontal position [m]
            YT = XOUT(:,2);                 % Vertical position [m]
            PSI = XOUT(:,3);                % Vehicle yaw angle [rad]
            dPSI = XOUT(:,4);               % Yaw rate [rad/s]
            VT = XOUT(:,5);                 % Vehicle CG velocity [m/s]
            ALPHAT = XOUT(:,6);             % Vehicle side slip angle [rad]

            % Distances
            a = self.vehicle.distFT;        % Distance FT [m]
            b = self.vehicle.distTR;        % Distance TR [m]
            lT = self.vehicle.width / 2;  % Metade da width do vehicle [m]

            % �ngulo de deriva na dianteira [rad]
            ALPHAF = atan2((a*dPSI + VT.*sin(ALPHAT)),(VT.*cos(ALPHAT)));
            % �ngulo de deriva na traseira [rad]
            ALPHAR = atan2((-b*dPSI + VT.*sin(ALPHAT)),(VT.*cos(ALPHAT)));
            % OBS: Calculando os �ngulos de deriva com "atan2", quando o valor chega a
            % 180 graus fica estranho o vector.

            % M�dulo da velocidade no eixo dianteiro [m/s]
            VF = sqrt((VT.*cos(ALPHAT)).^2 + (a*dPSI + VT.*sin(ALPHAT)).^2);
            % M�dulo da velocidade no eixo traseiro [m/s]
            VR = sqrt((VT.*cos(ALPHAT)).^2 + (-b*dPSI + VT.*sin(ALPHAT)).^2);

            % Posi��o relativa dos cantos e eixos
            % Determina a posi��o dos cantos e eixos do ve�culo com rela��o ao centro
            % de massa.

            % Vectores posi��o 1, 2, 3 e 4 em rela��o a T na base (T t1 t2 t3)
            rt1t = [a;lT];                  % dianteira esquerda
            rt2t = [a;-lT];                 % dianteira direita
            rt3t = [-b;-lT];                % traseira direita
            rt4t = [-b;lT];                 % traseira esquerda

            eif = [a;0];                    % Posicao do eixo dianteiro
            eir = [-b;0];                   % Posicao do eixo trasiero

            % Evolu��o da posi��o absoluta dos cantos e eixos
            % Determina a movimenta��o dos pontos devido a mudan�a de orienta��o do
            % ve�culo.

            % Pre alocando as matrizes

            rt1i = zeros(length(TOUT),2);
            rt2i = zeros(length(TOUT),2);
            rt3i = zeros(length(TOUT),2);
            rt4i = zeros(length(TOUT),2);

            eff = zeros(length(TOUT),2);
            err = zeros(length(TOUT),2);

            % In�cio do loop
            for j=1:length(TOUT)
                % Matriz de rota��o da base (T t1 t2 t3) para (o i j k)
                RTI=[cos(PSI(j)) -sin(PSI(j));sin(PSI(j)) cos(PSI(j))];
                % Vectores posi��o 1, 2, 3 e 4 em rela��o a origem do ref inercial na
                rt1i(j,1:2) = (RTI*rt1t)';
                % base (T t1 t2 t3)
                rt2i(j,1:2) = (RTI*rt2t)';
                rt3i(j,1:2) = (RTI*rt3t)';
                rt4i(j,1:2) = (RTI*rt4t)';
                % Posicionando o eixo dianteiro e o traseiro
                eff(j,1:2) = (RTI*eif);     % Eixo dianteiro
                err(j,1:2) = (RTI*eir);     % Eixo trasiro
            end

            % Posi��o absoluta dos cantos e eixos
            % A evolu��o da posi��o absoluta dos pontos ao longo do tempo.

            % Vectores posi��o 1, 2, 3 e 4 em rela��o a o na base (o i j k)
            rc1t=[XT YT]+rt1i;
            rc2t=[XT YT]+rt2i;
            rc3t=[XT YT]+rt3i;
            rc4t=[XT YT]+rt4i;

            % Posicionamento absoluto do eixo dianteiro e trasiero
            ef = [XT YT]+eff;
            er = [XT YT]+err;

            % Ajuste do tempo
            % A exibi��o deve ser ajustada pois a o n�mero de frames n�o � a mesma que
            % a resolu��o do integrador (TSPAN).
            %

            TEMPO = 0:0.05:TOUT(end);

            % Pre alocando as matrizes
            rc1 = zeros(length(TEMPO),2);
            rc2 = zeros(length(TEMPO),2);
            rc3 = zeros(length(TEMPO),2);
            rc4 = zeros(length(TEMPO),2);

            efrente = zeros(length(TEMPO),2);
            etras = zeros(length(TEMPO),2);

            xxx = zeros(length(TEMPO),2);
            yyy = zeros(length(TEMPO),2);
            alphat = zeros(length(TEMPO),2);
            psii = zeros(length(TEMPO),2);

            alphaf = zeros(length(TEMPO),2);
            alphar = zeros(length(TEMPO),2);

            velf = zeros(length(TEMPO),2);
            velr = zeros(length(TEMPO),2);
            velt = zeros(length(TEMPO),2);

            rn1 = zeros(length(TEMPO),2);
            rn2 = zeros(length(TEMPO),2);
            rn3 = zeros(length(TEMPO),2);
            rn4 = zeros(length(TEMPO),2);

            for i=1:length(TEMPO)
                % Posi��o dos cantos e eixo
                rc1(i,1:2) = interp1(TOUT,rc1t,TEMPO(i));
                rc2(i,1:2) = interp1(TOUT,rc2t,TEMPO(i));
                rc3(i,1:2) = interp1(TOUT,rc3t,TEMPO(i));
                rc4(i,1:2) = interp1(TOUT,rc4t,TEMPO(i));

                efrente(i,1:2) = interp1(TOUT,ef,TEMPO(i));
                etras(i,1:2) = interp1(TOUT,er,TEMPO(i));

                % Posi��o do centro de massa
                xxx(i,1:2) = interp1(TOUT,XT,TEMPO(i));
                yyy(i,1:2) = interp1(TOUT,YT,TEMPO(i));

                % Estados
                alphat(i,1:2) = interp1(TOUT,ALPHAT,TEMPO(i));
                psii(i,1:2) = interp1(TOUT,PSI,TEMPO(i));

                % �ngulos de deriva
                alphaf(i,1:2) = interp1(TOUT,ALPHAF,TEMPO(i));
                alphar(i,1:2) = interp1(TOUT,ALPHAR,TEMPO(i));

                % Velocidade
                velf(i,1:2) = interp1(TOUT,VF,TEMPO(i));
                velr(i,1:2) = interp1(TOUT,VR,TEMPO(i));
                velt(i,1:2) = interp1(TOUT,VT,TEMPO(i));
            end

            % Definindo a figura
            % Gerando a figura e definindo algumas propriedades
            f=figure(666);
            set(f,'Units','centimeters')
            set(f,'Position',[1 1 24 14])
            ax=gca();
            axis equal
            set(ax,'NextPlot','add','Box','on','XGrid','on','YGrid','on','ZGrid','on')
            set(ax,'XLim',[min(XT)-10 max(XT)+10])
            set(ax,'XLimMode','manual')
            set(ax,'YLim',[min(YT)-10 max(YT)+10])
            set(ax,'YLimMode','manual')

            % Legendas
            title('Trajet\''oria','Interpreter','Latex')
            xlabel('Dist\^ancia [m]','Interpreter','Latex');
            ylabel('Dist\^ncia [m]','Interpreter','Latex');

            % Primeiro frame
            %
            %

            % Vectores velocidade
            % Script "vector.m"
            % Escolhi n�o exibir o vector velocidade do centro de massa pq fica muito poluido
            %vector([xxx(1) yyy(1)],(alphat(1)+psii(1)),velt(1),'k');
            self.Vector(efrente(1,1:2),(alphaf(1)+psii(1)),velf(1),'r');
            self.Vector(etras(1,1:2),(alphar(1)+psii(1)),velr(1),'g');

            % Coordenadas dos cantos para o primeiro frame
            xc = [rc1(1,1) rc2(1,1) rc3(1,1) rc4(1,1)];
            yc = [rc1(1,2) rc2(1,2) rc3(1,2) rc4(1,2)];

            % Exibindo o ve�culo
            fill(xc,yc,'r')

            % Adding semitrailer
            if col == 8
                PHI = XOUT(:,7);        % Orienta��o relativa do semirreboque [rad]
                dPHI = XOUT(:,8);       % Velocidade angular relativa entre as unidades [rad/s]

                c = self.vehicle.distRA;        % distancia da articula��o ao centro de massa do caminh�o-trator [m]
                d = self.vehicle.distAS;        % distancia do eixo traseiro ao centro de massa do caminh�o-trator [m]
                e = self.vehicle.distSM;        % distancia da articula��o ao centro de massa do caminh�o-trator [m]
                lS = self.vehicle.widthSemi / 2;              % Metade da width do vehicle [m]

                % �ngulo de deriva no eixo do semirreboque [rad]
                ALPHAM = atan2(((d + e)*(dPHI - dPSI) + VT.*sin(ALPHAT + PHI) - b*dPSI.*cos(PHI) - c*dPSI.*cos(PHI)),(VT.*cos(ALPHAT + PHI) + b*dPSI.*sin(PHI) + c*dPSI.*sin(PHI)));
                % M�dulo da velocidade no eixo do semirreboque [m/s]
                VM = sqrt((VT.*cos(ALPHAT + PHI) + b*dPSI.*sin(PHI) + c*dPSI.*sin(PHI)).^2 + ((d + e)*(dPHI - dPSI) + VT.*sin(ALPHAT + PHI) - b*dPSI.*cos(PHI) - c*dPSI.*cos(PHI)).^2);
                RS = [XT-(b+c)*cos(PSI)-d*cos(PSI-PHI) YT-(b+c)*sin(PSI)-d*sin(PSI-PHI)];
                % Vectores posi��o 1, 2, 3 e 4 em rela��o a S na base (S s1 s2 s3)
                rs1s = [d;lS];           % dianteira esquerda
                rs2s = [d;-lS];          % dianteira direita
                rs3s = [-e;-lS];         % traseira direita
                rs4s = [-e;lS];          % traseira esquerda

                eim = [-e;0];           % Posicao do eixo do semirreboque

                rn1i = zeros(length(TOUT),2);
                rn2i = zeros(length(TOUT),2);
                rn3i = zeros(length(TOUT),2);
                rn4i = zeros(length(TOUT),2);

                emm = zeros(length(TOUT),2);

                for j=1:length(TOUT)
                    % Matriz de rota��o da base (S s1 s2 s3) para (o i j k)
                    RSI=[cos(PSI(j)-PHI(j)) -sin(PSI(j)-PHI(j));sin(PSI(j)-PHI(j)) cos(PSI(j)-PHI(j))];
                    % Vectores posi��o 1, 2, 3 e 4 em rela��o a O na base (c c1 c2 c3)
                    rn1i(j,1:2) = (RSI*rs1s)';
                    rn2i(j,1:2) = (RSI*rs2s)';
                    rn3i(j,1:2) = (RSI*rs3s)';
                    rn4i(j,1:2) = (RSI*rs4s)';

                    % Posicionando o eixo dianteiro e o traseiro
                    emm(j,1:2) = (RSI*eim);     % Eixo trasiro
                end

                % Vectores posi��o 1, 2, 3 e 4 em rela��o a o na base (o i j k)
                rn1t=RS+rn1i;
                rn2t=RS+rn2i;
                rn3t=RS+rn3i;
                rn4t=RS+rn4i;

                em = RS+emm;

                phii = zeros(length(TEMPO),2);
                alpham = zeros(length(TEMPO),2);
                velm = zeros(length(TEMPO),2);
                emsemi = zeros(length(TEMPO),2);

                for i=1:length(TEMPO)
                    phii(i,1:2) = interp1(TOUT,PHI,TEMPO(i));
                    alpham(i,1:2) = interp1(TOUT,ALPHAM,TEMPO(i));
                    velm(i,1:2) = interp1(TOUT,VM,TEMPO(i));
                    % Semirreboque
                    rn1(i,1:2) = interp1(TOUT,rn1t,TEMPO(i));
                    rn2(i,1:2) = interp1(TOUT,rn2t,TEMPO(i));
                    rn3(i,1:2) = interp1(TOUT,rn3t,TEMPO(i));
                    rn4(i,1:2) = interp1(TOUT,rn4t,TEMPO(i));

                    emsemi(i,1:2) = interp1(TOUT,em,TEMPO(i));
                end

                self.Vector(emsemi(1,1:2),(alpham(1)+psii(1)-phii(1)),velm(1),'b');
                xn = [rn1(1,1) rn2(1,1) rn3(1,1) rn4(1,1)];
                yn = [rn1(1,2) rn2(1,2) rn3(1,2) rn4(1,2)];
                fill(xn,yn,'g')
            end


            if saveit == 1
                % Inicializando o gif
                frame = getframe(666);
                im = frame2im(frame);
                [A,map] = rgb2ind(im,256,'nodither');
                imwrite(A,map,'Animacao.gif','LoopCount',Inf,'DelayTime',0.05);
            end

            % Frames restantes
            %
            for j = 1:length(TEMPO)
                % Trajet�ria do centro de massa

                % Centro de massa (Comentado porque n�o sei se vou usar)
                % plot(XT,YT,'r')
                % plot(RS(:,1),RS(:,2),'g')

                % Eixos
                plot(efrente(:,1),efrente(:,2),'r')
                plot(etras(:,1),etras(:,2),'g')

                % Coordenadas dos cantos para os frames
                xc = [rc1(j,1) rc2(j,1) rc3(j,1) rc4(j,1)];
                yc = [rc1(j,2) rc2(j,2) rc3(j,2) rc4(j,2)];


                % Exibindo o ve�culo
                fill(xc,yc,'r')

                % Vectores velocidade
                % Com cores diferentes
                % Escolhi n�o exibir o vector velocidade do centro de massa pq fica muito poluido
                %vector([xxx(j) yyy(j)],(alphat(j)+psii(j)),velt(j),'k');
                self.Vector(efrente(j,1:2),(alphaf(j)+psii(j)),velf(j),'r');
                self.Vector(etras(j,1:2),(alphar(j)+psii(j)),velr(j),'g');

                if col == 8
                    plot(emsemi(:,1),emsemi(:,2),'b')
                    xn = [rn1(j,1) rn2(j,1) rn3(j,1) rn4(j,1)];
                    yn = [rn1(j,2) rn2(j,2) rn3(j,2) rn4(j,2)];
                    fill(xn,yn,'g')
                    self.Vector(emsemi(j,1:2),(alpham(j)+psii(j)-phii(j)),velm(j),'b');
                end

                if saveit == 1
                    % Adicionando o frame atual ao gif iniciado
                    frame = getframe(666);
                    im = frame2im(frame);
                    [A,map] = rgb2ind(im,256,'nodither');
                    imwrite(A,map,'Animacao.gif','WriteMode','append','DelayTime',0.05);
                end
                % Pausa a exibi��o - ATEN��O: Tem que ser o mesmo valor usado no ajuste
                % do tempo

                pause(0.05)

                cla(ax); % Limpando o axes
            end

            % �ltimo frame
            % A �ltima imagem que a figura vai exibir quando a anima��o acabar
            %

            % Eixos
            plot(efrente(:,1),efrente(:,2),'r')
            plot(etras(:,1),etras(:,2),'g')

            % Coordenadas dos cantos para o �ltimo frame
            xc = [rc1(end,1) rc2(end,1) rc3(end,1) rc4(end,1)];
            yc = [rc1(end,2) rc2(end,2) rc3(end,2) rc4(end,2)];

            % Exibindo o ve�culo
            fill(xc,yc,'r')

            % Escolhi n�o exibir o vector velocidade do centro de massa pq fica muito poluido
            %vector([xxx(end) yyy(end)],(alphat(end)+psii(end)),velt(end),'k');
            self.Vector(efrente(end,1:2),(alphaf(end)+psii(end)),velf(end),'r');
            self.Vector(etras(end,1:2),(alphar(end)+psii(end)),velr(end),'g');

            % Incluindo o semirreboque
            if col == 8
                plot(emsemi(:,1),emsemi(:,2),'b')
                xn = [rn1(end,1) rn2(end,1) rn3(end,1) rn4(end,1)];
                yn = [rn1(end,2) rn2(end,2) rn3(end,2) rn4(end,2)];
                fill(xn,yn,'g')
                self.Vector(emsemi(end,1:2),(alpham(end)+psii(end)-phii(end)),velm(end),'b');
            end
        end

        %% Frame
        % Plots the sequence of frames of the vehicle manoever.
        %
        % *Sintax*
        %
        % |_GraphicsClass_.Frame(XOUT,TOUT,saveit)|
        %
        % *Arguments*
        %
        % The following table describes the input arguments:
        %
        % <html> <table border=1 width="97%">
        % <tr> <td width="30%"><tt>XOUT</tt></td> <td width="70%">Solution array. Each column corresponds to the solution of each state variable of the vehicle. The columns must respect the following variable order: [XT YT PSI dPSI VT ALPHAT (PHI dPHI)] </td> </tr>
        % <tr> <td width="30%"><tt>TOUT</tt></td> <td width="70%">Column vector of time points.</td> </tr>
        % <tr> <td width="30%"><tt>saveit</tt></td> <td width="70%">Flag for saving the trajectory image in a pdf file. If savit = 0 the image will not be saved. If savit = 1 a file Trajetoria.pdf is generated.</td> </tr>
        % </table> </html>
        %
        % *Description*
        %
        % TEXTO

        function Frame(self,XOUT,TOUT,saveit)
            % Verificando quantidade de colunas para saber se � ve�culo simples ou articulado
            % col = 6 -> simples
            % col = 8 -> articulado
            [col] = size(XOUT,2);

            % States
            XT = XOUT(:,1);                 % Horizontal position [m]
            YT = XOUT(:,2);                 % Vertical position [m]
            PSI = XOUT(:,3);                % Vehicle yaw angle [rad]
            dPSI = XOUT(:,4);               % Yaw rate [rad/s]
            VT = XOUT(:,5);                 % Vehicle CG velocity [m/s]
            ALPHAT = XOUT(:,6);             % Vehicle side slip angle [rad]

            % Distances
            a = self.vehicle.distFT;        % Distance FT [m]
            b = self.vehicle.distTR;        % Distance TR [m]
            lT = self.vehicle.width / 2;  % Metade da width do vehicle [m]

            % Slip angles
            ALPHAF = atan2((a*dPSI + VT.*sin(ALPHAT)),(VT.*cos(ALPHAT)));   % Front [rad]
            % OBS: N�o tem o delta pq � pra medir o �ngulo entre o vector velocidade do eixo dianteiro e o plano longitudinal do ve�culo
            ALPHAR = atan2((-b*dPSI + VT.*sin(ALPHAT)),(VT.*cos(ALPHAT)));  % Rear [rad]

            %
            % OBS: Calculando os �ngulos de deriva com "atan2", quando o valor chega a
            % 180 graus fica estranho o vector.
            %
            % Velocity
            VF = sqrt((VT.*cos(ALPHAT)).^2 + (a*dPSI + VT.*sin(ALPHAT)).^2);    % Front [m/s]
            VR = sqrt((VT.*cos(ALPHAT)).^2 + (-b*dPSI + VT.*sin(ALPHAT)).^2);   % Rear [m/s]

            % Posi��o relativa dos cantos e eixos
            % Determina a posi��o dos cantos e eixos do ve�culo com rela��o ao centro
            % de massa.
            % Vectores posi��o 1, 2, 3 e 4 em rela��o a T na base (T t1 t2 t3)
            rt1t = [a;lT];           % dianteira esquerda
            rt2t = [a;-lT];          % dianteira direita
            rt3t = [-b;-lT];         % traseira direita
            rt4t = [-b;lT];          % traseira esquerda

            eif = [a;0];            % Posicao do eixo dianteiro
            eir = [-b;0];           % Posicao do eixo trasiero

            % Pre alocando
            rt1i = zeros(length(TOUT),2);
            rt2i = zeros(length(TOUT),2);
            rt3i = zeros(length(TOUT),2);
            rt4i = zeros(length(TOUT),2);

            eff = zeros(length(TOUT),2);
            err = zeros(length(TOUT),2);

            % Evolu��o da posi��o absoluta dos cantos e eixos
            % Determina a movimenta��o dos pontos devido a mudan�a de orienta��o do
            % ve�culo.
            for j=1:length(TOUT)
                % Matriz de rota��o da base (T t1 t2 t3) para (o i j k)
                RTI=[cos(PSI(j)) -sin(PSI(j));sin(PSI(j)) cos(PSI(j))];
                % Vectores posi��o 1, 2, 3 e 4 em rela��o a origem do ref inercial na
                % base (T t1 t2 t3)
                rt1i(j,1:2) = (RTI*rt1t)';
                rt2i(j,1:2) = (RTI*rt2t)';
                rt3i(j,1:2) = (RTI*rt3t)';
                rt4i(j,1:2) = (RTI*rt4t)';
                % Posicionando o eixo dianteiro e o traseiro
                eff(j,1:2) = (RTI*eif);     % Eixo dianteiro
                err(j,1:2) = (RTI*eir);     % Eixo trasiro
            end

            % Posi��o absoluta dos cantos e eixos
            % A evolu��o da posi��o absoluta dos pontos ao longo do tempo.
            % Vectores posi��o 1, 2, 3 e 4 em rela��o a o na base (o i j k)
            rc1t=[XT YT]+rt1i;
            rc2t=[XT YT]+rt2i;
            rc3t=[XT YT]+rt3i;
            rc4t=[XT YT]+rt4i;
            % Posicionamento absoluto do eixo dianteiro e trasiero
            ef = [XT YT]+eff;
            er = [XT YT]+err;

            % Ajuste do tempo
            % A exibi��o deve ser ajustada pois a o n�mero de frames n�o � a mesma que
            % a resolu��o do integrador (TSPAN).
            %
            % A vari�vel tempo define em que instantes o ve�culo vai ser plotado
            TEMPO = 0:1:TOUT(end);

            % Pre alocando as matrizes
            rc1 = zeros(length(TEMPO),2);
            rc2 = zeros(length(TEMPO),2);
            rc3 = zeros(length(TEMPO),2);
            rc4 = zeros(length(TEMPO),2);

            efrente = zeros(length(TEMPO),2);
            etras = zeros(length(TEMPO),2);

            xxx = zeros(length(TEMPO),2);
            yyy = zeros(length(TEMPO),2);
            alphat = zeros(length(TEMPO),2);
            psii = zeros(length(TEMPO),2);

            alphaf = zeros(length(TEMPO),2);
            alphar = zeros(length(TEMPO),2);

            velf = zeros(length(TEMPO),2);
            velr = zeros(length(TEMPO),2);
            velt = zeros(length(TEMPO),2);

            for i=1:length(TEMPO)
                % Posi��o dos cantos e eixo
                rc1(i,1:2) = interp1(TOUT,rc1t,TEMPO(i));
                rc2(i,1:2) = interp1(TOUT,rc2t,TEMPO(i));
                rc3(i,1:2) = interp1(TOUT,rc3t,TEMPO(i));
                rc4(i,1:2) = interp1(TOUT,rc4t,TEMPO(i));
                % Posi��o do centro de massa
                xxx(i,1:2) = interp1(TOUT,XT,TEMPO(i));
                yyy(i,1:2) = interp1(TOUT,YT,TEMPO(i));
                % Estados
                alphat(i,1:2) = interp1(TOUT,ALPHAT,TEMPO(i));
                psii(i,1:2) = interp1(TOUT,PSI,TEMPO(i));
                % �ngulos de deriva
                alphaf(i,1:2) = interp1(TOUT,ALPHAF,TEMPO(i));
                alphar(i,1:2) = interp1(TOUT,ALPHAR,TEMPO(i));
                % Velocidade
                velf(i,1:2) = interp1(TOUT,VF,TEMPO(i));
                velr(i,1:2) = interp1(TOUT,VR,TEMPO(i));
                velt(i,1:2) = interp1(TOUT,VT,TEMPO(i));
            end

            % Definindo a figura
            % Gerando a figura e definindo algumas propriedades
            %
            f999 = figure(999);
            set(f999,'Units','centimeters')
            set(f999,'Position',[1 1 24 14])
            set(f999,'PaperUnits','centimeters')
            set(f999,'PaperPosition',[5 0 16 12])
            PaperPos = get(f999,'PaperPosition');
            set(f999,'PaperSize',PaperPos(3:4))
            ax999=gca();
            set(ax999,'NextPlot','add','Box','on','XGrid','on','YGrid','on','ZGrid','on')
            axis equal
            set(ax999,'XLim',[min(XT)-20 max(XT)+10])
            set(ax999,'XLimMode','manual')
            set(ax999,'YLim',[min(YT)-10 max(YT)+10])
            set(ax999,'YLimMode','manual')

            xlabel('Dist\^ancia [m]','Interpreter','Latex')
            ylabel('Dist\^ancia [m]','Interpreter','Latex')

            TEMPOplot = 0:0.05:TOUT(end); % Tempo para os plot da curva de trajet�ria
            for i=1:length(TEMPOplot)
                efrente(i,1:2) = interp1(TOUT,ef,TEMPOplot(i));
                etras(i,1:2) = interp1(TOUT,er,TEMPOplot(i));
            end

            % plot(efrente(:,1),efrente(:,2),'r')
            % plot(etras(:,1),etras(:,2),'g')
            plot(ef(:,1),ef(:,2),'r')
            plot(er(:,1),er(:,2),'g')

            for j = 1:length(TEMPO)
                % Coordenadas dos cantos para os frames
                xc = [rc1(j,1) rc2(j,1) rc3(j,1) rc4(j,1)];
                yc = [rc1(j,2) rc2(j,2) rc3(j,2) rc4(j,2)];
                % Exibindo o ve�culo
                fill(xc,yc,'r');
            end

            % Adding semitrailer
            if col == 8
                PHI = XOUT(:,7);        % Orienta��o relativa do semirreboque [rad]
                dPHI = XOUT(:,8);       % Velocidade angular relativa entre as unidades [rad/s]

                c = self.vehicle.distRA;        % distancia da articula��o ao centro de massa do caminh�o-trator [m]
                d = self.vehicle.distAS;        % distancia do eixo traseiro ao centro de massa do caminh�o-trator [m]
                e = self.vehicle.distSM;        % distancia da articula��o ao centro de massa do caminh�o-trator [m]
                lS = self.vehicle.widthSemi / 2;              % Metade da width do vehicle [m]
                % �ngulo de deriva no eixo do semirreboque [rad]
                ALPHAM = atan2(((d + e)*(dPHI - dPSI) + VT.*sin(ALPHAT + PHI) - b*dPSI.*cos(PHI) - c*dPSI.*cos(PHI)),(VT.*cos(ALPHAT + PHI) + b*dPSI.*sin(PHI) + c*dPSI.*sin(PHI)));
                % M�dulo da velocidade no eixo do semirreboque [m/s]
                VM = sqrt((VT.*cos(ALPHAT + PHI) + b*dPSI.*sin(PHI) + c*dPSI.*sin(PHI)).^2 + ((d + e)*(dPHI - dPSI) + VT.*sin(ALPHAT + PHI) - b*dPSI.*cos(PHI) - c*dPSI.*cos(PHI)).^2);
                % Posi��o do centro de massa do semirreboque
                RS = [XT-(b+c)*cos(PSI)-d*cos(PSI-PHI) YT-(b+c)*sin(PSI)-d*sin(PSI-PHI)];
                % Vectores posi��o 1, 2, 3 e 4 em rela��o a S na base (S s1 s2 s3)
                rs1s = [d;lS];           % dianteira esquerda
                rs2s = [d;-lS];          % dianteira direita
                rs3s = [-e;-lS];         % traseira direita
                rs4s = [-e;lS];          % traseira esquerda
                eim = [-e;0];           % Posicao do eixo do semirreboque
                % Pre alocando
                rn1i = zeros(length(TOUT),2);
                rn2i = zeros(length(TOUT),2);
                rn3i = zeros(length(TOUT),2);
                rn4i = zeros(length(TOUT),2);
                emm = zeros(length(TOUT),2);

                for j=1:length(TOUT)
                    % Matriz de rota��o da base (S s1 s2 s3) para (o i j k)
                    RSI=[cos(PSI(j)-PHI(j)) -sin(PSI(j)-PHI(j));sin(PSI(j)-PHI(j)) cos(PSI(j)-PHI(j))];
                    % Vectores posi��o 1, 2, 3 e 4 em rela��o a O na base (c c1 c2 c3)
                    rn1i(j,1:2) = (RSI*rs1s)';
                    rn2i(j,1:2) = (RSI*rs2s)';
                    rn3i(j,1:2) = (RSI*rs3s)';
                    rn4i(j,1:2) = (RSI*rs4s)';
                    % Posicionando o eixo dianteiro e o traseiro
                    emm(j,1:2) = (RSI*eim);     % Eixo trasiro
                end
                % Vectores posi��o 1, 2, 3 e 4 em rela��o a o na base (o i j k)
                rn1t=RS+rn1i;
                rn2t=RS+rn2i;
                rn3t=RS+rn3i;
                rn4t=RS+rn4i;

                em = RS+emm;

                phii = zeros(length(TEMPO),2);
                alpham = zeros(length(TEMPO),2);
                velm = zeros(length(TEMPO),2);
                rn1 = zeros(length(TEMPO),2);
                rn2 = zeros(length(TEMPO),2);
                rn3 = zeros(length(TEMPO),2);
                rn4 = zeros(length(TEMPO),2);
                emsemi = zeros(length(TEMPO),2);

                for i=1:length(TEMPO)
                    phii(i,1:2) = interp1(TOUT,PHI,TEMPO(i));
                    alpham(i,1:2) = interp1(TOUT,ALPHAM,TEMPO(i));
                    velm(i,1:2) = interp1(TOUT,VM,TEMPO(i));

                    rn1(i,1:2) = interp1(TOUT,rn1t,TEMPO(i));
                    rn2(i,1:2) = interp1(TOUT,rn2t,TEMPO(i));
                    rn3(i,1:2) = interp1(TOUT,rn3t,TEMPO(i));
                    rn4(i,1:2) = interp1(TOUT,rn4t,TEMPO(i));
                end
                for i=1:length(TEMPOplot)
                    emsemi(i,1:2) = interp1(TOUT,em,TEMPOplot(i));
                end
                plot(em(:,1),em(:,2),'b')
                % plot(emsemi(:,1),emsemi(:,2),'b')

                for j = 1:length(TEMPO)
                    xn = [rn1(j,1) rn2(j,1) rn3(j,1) rn4(j,1)];
                    yn = [rn1(j,2) rn2(j,2) rn3(j,2) rn4(j,2)];
                    fill(xn,yn,'g');
                end
            end

            if saveit == 1
                print(f999,'-dpdf','Trajetoria.pdf')
            end
        end
    end

    methods(Static)

        %% Vector
        % Plots a vector arrow.
        %
        % *Sintax*
        %
        % |_GraphicsClass_.Vector(inicio,angulo,modulo,cor)|
        %
        % *Arguments*
        %
        % The following table describes the input arguments:
        %
        % <html> <table border=1 width="97%">
        % <tr> <td width="30%"><tt>inicio</tt></td> <td width="70%">Coordenada do �nicio da flecha.</td> </tr>
        % <tr> <td width="30%"><tt>angulo</tt></td> <td width="70%">�ngulo da orienta��o da flecha.</td> </tr>
        % <tr> <td width="30%"><tt>M�dulo</tt></td> <td width="70%">Comprimento da flecha.</td> </tr>
        % <tr> <td width="30%"><tt>cor</tt></td> <td width="70%">Cor da flecha.</td> </tr>
        % </table> </html>
        %
        % *Description*
        %
        % TEXTO

        function Vector(inicio,angulo,modulo,cor)
            coord1 = inicio;                                    % inicio do vector
            theta = angulo;
            modulo = 0.7*modulo;                                % modulo do vector
            coord2 = modulo*[cos(theta) sin(theta)] + coord1;   % fim do vector

            %theta = atan2((coord1(1)-coord2(1)),(coord1(2)-coord2(2))); % angulo de orienta��o do triangulo
            esc = 1; % Escala
            l = 0.5; % width relativa em rela��o ao comprimento do triangulo (0-1)

            % Forma e orienta��o do triangulo
            c1 = esc*l*[-sin(theta) +cos(theta)];   % canto 1 - inferior esquerdo
            c2 = esc*l*[+sin(theta) -cos(theta)];   % canto 2 - inferior direito
            c3 = esc*[+cos(theta) +sin(theta)];     % canto 3 - superior central

            % Escala e posicionamento
            x = [c1(1)+coord2(1) c2(1)+coord2(1) c3(1)+coord2(1)];
            y = [c1(2)+coord2(2) c2(2)+coord2(2) c3(2)+coord2(2)];

            % figure(1)
            % axis equal
            hold on
            fill(x,y,cor)
            p = plot([coord1(1) coord2(1)],[coord1(2) coord2(2)],cor);
            set(p,'LineWidth',2)
            % Id�ia de colocar um marcador no in�cio do vector
            % m = plot(coord1(1),coord1(2),strcat('*',cor));
            % set(m,'MarkerSize',10)
        end

        %% changeMarker
        % A fun��o changeMarker altera o n�mero de marcadores num plot.
        %
        % *Sintax*
        %
        % |_GraphicsClass_.changeMarker(p,n)|
        %
        % *Arguments*
        %
        % The following table describes the input arguments:
        %
        % <html> <table border=1 width="97%">
        % <tr> <td width="30%"><tt>p</tt></td> <td width="70%">Handle do plot.</td> </tr>
        % <tr> <td width="30%"><tt>n</tt></td> <td width="70%">N�mero de marcadores que devem ser exibidos.</td> </tr>
        % </table> </html>
        %
        % *Description*
        %
        % TEXTO

        function changeMarker(p,n)
            % p - handle of plot
            % n - number of markers

            % Line info
            line_color = get(p,'Color');
            line_Style = get(p,'LineStyle');
            line_LineWidth = get(p,'LineWidth');
            % Marker info
            marker_type = get(p,'Marker');
            marker_size = get(p,'MarkerSize');
            marker_EdgeColor = get(p,'MarkerEdgeColor');
            marker_FaceColor = get(p,'MarkerFaceColor');
            % Axis info
            vec_XData = get(p,'XData');
            vec_YData = get(p,'YData');

            size_XData = length(vec_XData);

            step = floor((size_XData)/(n-1));

            % Fazendo o plot dos marcadores
            p_marker = plot(vec_XData(1:step:end),vec_YData(1:step:end));
            set(p_marker,'LineStyle','none','Marker',marker_type,'MarkerSize',marker_size,...
            	'MarkerEdgeColor',marker_EdgeColor,'MarkerFaceColor',marker_FaceColor)

            % Removendo o marcador do plot original
            set(p,'Marker','none')
            % Remover a visibilidade do handle do original e do marcador
            set(p,'HandleVisibility','off')
            set(p_marker,'HandleVisibility','off')

            % Dummy para legenda
            p_dummy = plot(vec_XData(1),vec_YData(1));
            set(p_dummy,'Color',line_color,'LineStyle',line_Style,'LineWidth',line_LineWidth,...
            	'Marker',marker_type,'MarkerSize',marker_size,...
            	'MarkerEdgeColor',marker_EdgeColor,'MarkerFaceColor',marker_FaceColor)
        end

    end

    %% Properties
    %

    properties
        vehicle
    end
end

%% See Also
%
% <index.html Index>
%

##### SOURCE END #####
--></body></html>